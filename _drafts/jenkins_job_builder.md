---
title: Jenkins Job Builder Templates by OpenStack
layout: default
excerpt: <p>Jenkins is a flexible and easy to use continous integration server. Coming from a Linux background, the GUI seems awkward and cumbersome to use. Enter Jenkins job templates. This is an excellent project by the people at OpenStack that allows you to define your jenkins jobs via yaml files. JJB then parses these yaml files and converts them into the XML format that Jenkins expects.</p>
 
---
### {{page.title}}

<p>Jenkins is a flexible and easy to use continous integration server. Coming from a Linux background, the GUI seems awkward and cumbersome to use. Enter Jenkins job templates. This is an excellent project by the people at OpenStack that allows you to define your jenkins jobs via yaml files. JJB then parses these yaml files and converts them into the XML format that Jenkins expects.</p>

JJB solves a few problems that I have encounted when using Jenkins:

1. Configuration drift - this is the familiar problem usually associated with hand-configured servers. Over time it becomes impossible to say with any degree of certainty exactly what is on a server if it is hand-configured. This is true of Jenkins as well for jobs that are setup using the GUI. The root cause is the high labour overhead of clicking through 50 configuration screens for 50 jobs.

2. Changing a common step across 50 build jobs means that you will need to step through 50 web pages. Very demoralising and from a developers perspective a sin.

3. Configuration done via the GUI screen cannot be versioned. Unless you start versioning the xml files that are generated by Jenkins. This gets ugly very fast and isnt a very elegant solution.

4. Most importantly though - your Jenkins server becomes special i.e. indispensible. 

#### Jobs 
This is an example job template written using JJB.

{% highlight yaml %}
- job-template:
    name: 'Run PHP unit tests'
    description: >
                  This job runs the php unit tests in this project.
    project-type: freestyle
    logrotate:
      numToKeep: 20
    scm:
      - git:
          url: 'git@github.com:atom/atom.git'
          branches:
            - 'origin/PreRelease'
          credentials-id: 'some-uuid'
    triggers:
      - pollscm: "* * * * *"
    builders:
      - shell: "make test"
{% endhighlight %}        

The job templates above is for the most part quite self-explanatory. It creates a job in Jenkins that polls a github repo every minute for changes and runs a set of commands when it finds that the repo has been updated. The credentials-id is the api key that needs to be provided to JJB so that it can talk to Jenkins via the REST api.

#### Job Templates
The example above is overly simplified. The power of JJB comes when you parameterise these job templates like so:

{% highlight yaml %}
- job-template:
    name: '{job_name}_unittests'
    description: >
                  {job_description}
    project-type: freestyle
    logrotate:
      numToKeep: 20
    scm:
      - git:
          url: '{git_repo_url}'
          branches:
            - '{branch_to_monitor}'
          credentials-id: '{api_key}'
    triggers:
      - pollscm: "{polling_interval}"
    builders:
      - shell: "make test"
{% endhighlight %}

Now we have a job template that can be fed with values for the variables. This paves the way for re-using the job template. So how do we supply these job templates with variables. Enter projects.

#### Projects
A project is again a yaml file that ties together job templates and variables.

{% highlight yaml %}
- project:
    name: 'Demo jjb project'
    api_key: 'bzzxx234-41asdf-4780-asdf9-f1poasdfsf'
    branch_to_monitor:
      - 'pre-master':
           job_name: 'PRE-MASTER'
      - 'master':
           display_branch_name: 'MASTER'
    project_name: 'codename_alpha'
    git_repo_url: 'git@example.com:company/project1.git'
    jobs:
      - '{job_name}_unittests'
      - '{job_name}_styletests'
{% endhighlight %}

Everything in the projects.yml file apart from the jobs list is a series of variable definitions that get substituted into the job templates listed under the jobs list. 

A powerful feature here is that you can define variables as lists. That causes JJB to create a job for every combination in the Cartesian product of the variables that are defined. In the projects.yml file above, it will cause the following jobs to be created:

PRE-MASTER_unittests: which will monitor the pre-master branch on the project1.git repo and run 'make test'
PRE-MASTER_styletests: which will monitor the pre-master branch on the project1.git repo and run 'make style'
MASTER_styletests: which will monitor the master branch on the project1.git repo and run 'make style'
MASTER_styletests: which will monitor the master branch on the project1.git repo and run 'make style'

Thats four jobs in jenkins written across 2 concise yaml files! We can now store these yaml files in a git repository. That paves the way for semantic versioning and peer reviews. 

If we need to change the specification of these jobs e.g. we want to change the polling interval we need only edit one config file and rebuild the job definitions.

