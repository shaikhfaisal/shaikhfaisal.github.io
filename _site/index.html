<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>fais.al</title>

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <div class="wrapper">
        <header>
            <h1><a href="http://fais.al/">Faisal</a></h1>
            <p>not for public consumption</p>


            <p class="view"><a href="https://github.com/shaikhfaisal">View My GitHub Profile</a></p>

        </header>
    <section>
        
    <article>
        <a href="/2014/11/27/jenkins_diamond_job_config/"> Diamond job configuration in Jenkins Job Builder </a> <span style="float:right"><i>2014-11-27</i></span>
        <p>Parallelising job execution in Jenkins can lead to a significant reduction in build execution times. The time it takes to complete a build becomes the time taken by the longest executing job.</p>
    </article>
    <hr>

    <article>
        <a href="/2014/11/27/jenkins_job_builder/"> Jenkins Job Builder Templates by OpenStack </a> <span style="float:right"><i>2014-11-27</i></span>
        <p>Jenkins is a flexible and easy to use continous integration server. Coming from a Linux background, the GUI seems awkward and cumbersome to use. Enter Jenkins job templates. This is an excellent project by the people at OpenStack that allows you to define your jenkins jobs via yaml files. JJB then parses these yaml files and converts them into the XML format that Jenkins expects.</p>
    </article>
    <hr>

    <article>
        <a href="/2014/10/30/git_add_patches/"> git add -i </a> <span style="float:right"><i>2014-10-30</i></span>
        <p>Submitting meaningful commits to your repository makes it easier for your future self and team-mates from understanding how and why changes were brought in. Instead of one gigantic commit that includes all the changes for a feature, splitting up your commits into a single commit per feature allows you to look at meaningful diffs at a commit level. This makes code reviews go smoother as you won't have to remember why you made a change.</p>
    </article>
    <hr>

    <article>
        <a href="/2013/12/31/packer-and-vagrant/"> Using packer to build vagrant base boxes </a> <span style="float:right"><i>2013-12-31</i></span>
        <p>I recently needed to build a Vagrant base box and but did not want to use the boxes that were pre-built and available on the internet. I wanted to build my own boxes from the original distribution ISOs. This is possible to do manually but is a laborious and slow process. Enter [Packer](packer.io) -  a tool from the developers of Vagrant that automates this so you can go from original distribution ISO to vagrant box by typing in one command. This lends itself to automation which is almost always a good thing.</p>
    </article>
    <hr>



    </section>
        <footer>
            <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
        </footer>
    </div>

    <script src="/javascripts/scale.fix.js"></script>

</body>
</html>
